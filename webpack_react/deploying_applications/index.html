<html><head><title>SurviveJS - Webpack and React - Deploying Applications</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="github-fork-ribbon-wrapper right"><div class="github-fork-ribbon" style="background-color:black;"><a href="https://github.com/survivejs/webpack_react/issues/new">Submit feedback</a></div></div><main role="main"><div class="post"><div class="docs-nav__wrapper docs-nav__wrapper--push-down"><h4 class="docs-nav--header">Table of Contents</h4><div class="docs-nav"><a href="/webpack_react/introduction" class="docs-nav__link">Introduction</a><a href="/webpack_react/webpack_compared" class="docs-nav__link">Webpack Compared</a><a href="/webpack_react/getting_started" class="docs-nav__link">Getting Started</a><a href="/webpack_react/developing_with_webpack" class="docs-nav__link">Developing with webpack</a><a href="/webpack_react/webpack_and_react" class="docs-nav__link">Webpack and React</a><a href="/webpack_react/implementing_notes" class="docs-nav__link">Implementing a Basic Note App</a><a href="/webpack_react/react_and_flux" class="docs-nav__link">React and Flux</a><a href="/webpack_react/from_notes_to_kanban" class="docs-nav__link">From Notes to Kanban</a><a href="/webpack_react/styling_react" class="docs-nav__link">Styling React</a><a href="/webpack_react/implementing_dnd" class="docs-nav__link">Implementing Drag and Drop</a><a href="/webpack_react/linting_in_webpack" class="docs-nav__link">Linting in webpack</a><span class="docs-nav__link docs-nav__link--current">Deploying Applications</span><a href="/webpack_react/authoring_libraries" class="docs-nav__link">Authoring Libraries</a><a href="/webpack_react/troubleshooting" class="docs-nav__link">Troubleshooting</a></div></div><div class="header-image" style="background-image:url(/images/boots.jpg);"></div><h1 class="post__heading">Deploying Applications</h1><div class="post__content"><div class="post__meta"></div><div><p>If you were developing a native application you would probably bundle everything into one file and deploy it to some application store. Size probably wouldn&apos;t matter that much. Web is different. You can get quite far with a single bundle but at a certain point that becomes unwieldy. This is the area where webpack excels. It will allow you to shape your bundles just the way you like it. In this chapter I will discuss more general strategies for dealing with it.</p>
<p>The strategy you&#x2019;ll want to use depends entirely on your goals. With webpack you can end up with something very highly optimized. This incurs some extra complexity to the configuration but your users will be very glad you gave that extra effort. So far you&apos;ve seen how to set up a basic minified bundle. The next step would be to split a vendor chunk from it.</p>
<a class="header-anchor" href="#splitting-app-and-vendors" id="splitting-app-and-vendors"></a><h2>Splitting App and Vendors<a class="header-anchor-select" href="#splitting-app-and-vendors">#</a></h2>
<p>Separating app and vendors can make sense when your dependencies are large compared to the project itself. This is beneficial when you do bug fixes or other changes to the application. In that case your users would just need to download your app bundle in case the vendor bundle remains unchanged. Compared to a single bundle initial loading will be slightly slower since each request comes with a slight overhead. But given we can leverage caching it&apos;s not a bad price to pay.</p>
<blockquote class="tip">Generally the more HTTP requests you have to fire, the slower things will get. Even though request payload itself might be small, each request comes with overhead. The overhead adds up quickly. This is the reason why clever bundling approaches are required. The situation is likely to change as HTTP/2 gets adopted. The situation is quite opposite there.</blockquote><p>Given the following project file structure:</p>
<ul>
<li>app/main.js</li>
<li>dist/</li>
<li>node_modules/react</li>
<li>package.json</li>
<li>webpack.production.js</li>
</ul>
<p>You can create a configuration like this:</p>
<p><strong>webpack.production.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;path&apos;</span>);
<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;webpack&apos;</span>);

<span class="hljs-keyword">var</span> ROOT_PATH = path.resolve(__dirname);

<span class="hljs-built_in">module</span>.exports = {
  entry: {
    app: [path.resolve(ROOT_PATH, <span class="hljs-string">&apos;app/main.js&apos;</span>)],
    vendors: [<span class="hljs-string">&apos;react&apos;</span>]
  },
  output: {
    path: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;dist&apos;</span>),
    filename: <span class="hljs-string">&apos;app.[chunkhash].js&apos;</span>
  },
  plugins: [
    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="hljs-string">&apos;vendors&apos;</span>, <span class="hljs-string">&apos;vendors.[chunkhash].js&apos;</span>)
  ]
};
</code></pre>
<p>This configuration will create two files in the <code>dist/</code> folder. <strong>app.js</strong> and <strong>vendors.js</strong>.</p>
<blockquote class="tip">Remember to add both files to your HTML file, or you will get the error: <code>Uncaught ReferenceError: webpackJsonp is not defined</code>.</blockquote><blockquote class="tip">That <code>[chunkhash]</code> up there is used for generating a unique id per chunk for caching. If chunk contents change, so does the hash. And as a result your client will reload the file. See <a href="http://webpack.github.io/docs/long-term-caching.html">long term caching</a> section at the official documentation for more information about the topic.</blockquote><p>The entry chunks and their individual children chunks will be bundled into two different JavaScript files, <strong>app.js</strong> and <strong>vendors.js</strong>. Both of the bundles has <code>react</code> as either part of the entry chunk itself, like vendors, or it is required with a <code>var React = require(&apos;react&apos;)</code> statement, like in app.</p>
<p>Understanding this, you can understand how the CommonsChunkPlugin works. In the example above, if we did not configure a plugin at all React would be included in both entry chunks, app and vendors, and bundled into both the <em>app.js</em> file and <em>vendors.js</em> file. By using a plugin we can tell webpack that the chunks included in vendors are common.</p>
<p>That means when an other entry chunk, like app in this example, tries to require react it will first check  entry chunks defined as common. In our example, using the CommonsChunkPlugin, we say that the vendors entry chunk is common and when it is bundled, call that file <strong>vendors.js</strong>. The result of this is that we will now get two bundles, app.js and vendors.js, where app.js grabs React from vendors.js.</p>
<a class="header-anchor" href="#multiple-bundles" id="multiple-bundles"></a><h2>Multiple Bundles<a class="header-anchor-select" href="#multiple-bundles">#</a></h2>
<p>Let&apos;s say you are working on a big project and you have a family of applications. These applications have different functionality, but they still share a lot of code. With webpack you can create completely separate bundles that share a single common bundle. How much should be shared is something webpack can optimize for you.</p>
<p>Given the following project file structure:</p>
<ul>
<li>appA/main.js</li>
<li>appB/main.js</li>
<li>dist/</li>
<li>node_modules/react</li>
<li>package.json</li>
<li>webpack.production.js</li>
</ul>
<p><strong>webpack.production.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;path&apos;</span>);
<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;webpack&apos;</span>);

<span class="hljs-keyword">var</span> ROOT_PATH = path.resolve(__dirname);

<span class="hljs-built_in">module</span>.exports = {
  entry: {
    appA: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;appA/main.js&apos;</span>),
    appB: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;appB/main.js&apos;</span>)
  },
  output: {
    path: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;dist&apos;</span>),
    filename: <span class="hljs-string">&apos;[name].js&apos;</span> <span class="hljs-comment">// Notice we use a variable</span>
  },
  plugins: [
    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="hljs-string">&apos;common&apos;</span>, <span class="hljs-string">&apos;common.js&apos;</span>)
  ]
};
</code></pre>
<p>This configuration will create three files in the <code>dist/</code> folder. <strong>appA.js</strong>, <strong>appB.js</strong> and <strong>common.js</strong>. There are two things you should notice here:</p>
<ol>
<li><p>We are using a variable in our output configuration. Since we have multiple entries we want to produce one file for each of them, using the name of the entry as the name of the file.</p>
</li>
<li><p>The CommonsChunkPlugin is now used a bit differently than in the previous strategy. Instead of pointing to an existing entry chunk, we create a brand new chunk called <em>common</em>. Its file name will be <em>common.js</em>. By default webpack will make sure that if one entry chunk or its children require a chunk that also the other entry chunk or its children require, it will be moved over to the common chunk. This effectively moves vendors and shared chunks to the common bundle.</p>
</li>
</ol>
<a class="header-anchor" href="#lazy-loaded-chunks" id="lazy-loaded-chunks"></a><h2>Lazy Loaded Chunks<a class="header-anchor-select" href="#lazy-loaded-chunks">#</a></h2>
<p>It is also possible to lazy load chunks. This means that you load parts of your application as they are requested. A typical scenario for this would be that your users only visits specific parts of the application. And an example of that would be twitter.com. You do not always visit your profile page, so why load the code for that? Here is a summary of requirements.</p>
<p>Given the following project file structure:</p>
<ul>
<li>app/main.js</li>
<li>app/Profile.js</li>
<li>dist/</li>
<li>node_modules/react</li>
<li>package.json</li>
<li>webpack.production.js</li>
</ul>
<p><strong>webpack.production.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;path&apos;</span>);
<span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;webpack&apos;</span>);

<span class="hljs-keyword">var</span> ROOT_PATH = path.resolve(__dirname);

<span class="hljs-built_in">module</span>.exports = {
  entry: {
    app: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;app/main.js&apos;</span>),
    vendors: [<span class="hljs-string">&apos;react&apos;</span>]
  },
  output: {
    path: path.resolve(ROOT_PATH, <span class="hljs-string">&apos;dist&apos;</span>),
    filename: <span class="hljs-string">&apos;app.js&apos;</span>
  },
  <span class="hljs-built_in">module</span>: {
    loaders: [{
      test: <span class="hljs-regexp">/\.js$/</span>,
      exclude: [path.resolve(ROOT_PATH, <span class="hljs-string">&apos;node_modules&apos;</span>)],
      loader: <span class="hljs-string">&apos;babel&apos;</span>
    }]
  },
  plugins: [
    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="hljs-string">&apos;vendors&apos;</span>, <span class="hljs-string">&apos;vendors.js&apos;</span>)
  ]
};
</code></pre>
<p>So we are pretty much back where we started with a split application and vendors bundle. You do not really define your lazy dependencies in a configuration, webpack automatically understands them when analyzing your code. So let us see how we would lazy load a <strong>profile page</strong>:</p>
<p><strong>main.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;
<span class="hljs-keyword">import</span> Feed <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Feed.js&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.state = { currentComponent: Feed };
  }
  openProfile() {
    <span class="hljs-built_in">require</span>.ensure([], () =&gt; {
      <span class="hljs-keyword">var</span> Profile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./Profile.js&apos;</span>);
      <span class="hljs-keyword">this</span>.setState({
        currentComponent: Profile
      });
    });
  }
  render() {
   <span class="hljs-keyword">return</span> (
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{this.state.currentComponent()}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>;
  }
}

React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">App</span>/&gt;</span>, document.body);
</span></code></pre>
<p>So this is just an example. You would probably hook this up to a router, but the important part is using <code>require.ensure</code>. When webpack finds that statement it will automatically create a chunk that can be lazy loaded.</p>
<blockquote class="tip"><strong>What is the array on the first argument?</strong>: If you try to lazy load a chunk that depends on an other lazy loaded chunk you can set it as a dependency in the array. Just type in the path to the chunk; e.g. <code>[&apos;./FunnyButton.js&apos;]</code></blockquote><a class="header-anchor" href="#isomorphic-app" id="isomorphic-app"></a><h2>Isomorphic App<a class="header-anchor-select" href="#isomorphic-app">#</a></h2>
<p>So the great thing about React is that it runs on the server too. But that does not mean you can just create any app and run it on the server. You have to make some decisions on the architecture. The reason is that even though React and the components run on the server, you might have dependencies in those components that do not run on the server.</p>
<p>One of the most important decisions you make is to inject the state of your application through the top component. This basically means that your components do not have any external dependencies at all. All they need to know comes through this injected state.</p>
<p><strong>main.js (client)</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;react&apos;</span>);
<span class="hljs-keyword">var</span> AppState = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./client/AppState.js&apos;</span>);
<span class="hljs-keyword">var</span> App = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./App.js&apos;</span>);

React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">App</span> <span class="hljs-attribute">state</span>=<span class="hljs-value">{AppState}</span>/&gt;</span>, document.body);
</span></code></pre>
<p><strong>router.js (server)</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;react&apos;</span>);
<span class="hljs-keyword">var</span> App = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./App.js&apos;</span>);
<span class="hljs-keyword">var</span> AppState = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./server/AppState.js&apos;</span>);
<span class="hljs-keyword">var</span> index = <span class="hljs-string">&apos;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;{{component}}&lt;/body&gt;&lt;/html&gt;&apos;</span>;

app.get(<span class="hljs-string">&apos;/&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">var</span> componentHtml = React.renderToString(App({state: AppState}));
  <span class="hljs-keyword">var</span> html = index.replace(<span class="hljs-string">&apos;{{component}}&apos;</span>, componentHtml);
  res.type(<span class="hljs-string">&apos;html&apos;</span>);
  res.send(html);
});
</code></pre>
<p>So this was a very naive and simple way of showing it, but what you should notice here is that we use the same <strong>App.js</strong> file on the client and server, but we have two different ways of producing the state.</p>
<a class="header-anchor" href="#conclusion" id="conclusion"></a><h2>Conclusion<a class="header-anchor-select" href="#conclusion">#</a></h2>
<p>In this chapter you saw some common strategies to help you deal with deployment. This is an area where webpack shines. You can configure it in various way to suit your purposes as you saw above.</p>
</div><div class="social-links"><blockquote>If you enjoyed this chapter, consider subscribing to <a href="http://eepurl.com/bth1v5">the mailing list</a> or following <a href="https://twitter.com/survivejs">@survivejs</a> for occasional updates. There is also <a href="/atom.xml">RSS</a> available for old beards (no pun intended).</blockquote></div><div id="disqus_thread"></div><div class="prevnext"><div class="prevnext__prev"><div class="prevnext__bg" style="background-image:url(/images/lint.jpg);"></div><span class="prevnext__info">Previous chapter</span><a class="prevnext__link" href="/webpack_react/linting_in_webpack">Linting in webpack</a></div><div class="prevnext__next"><div class="prevnext__bg" style="background-image:url(/images/library.jpg);"></div><span class="prevnext__info">Next chapter</span><a class="prevnext__link" href="/webpack_react/authoring_libraries">Authoring Libraries</a></div></div><a class="next-page" href="/webpack_react/authoring_libraries">Authoring Libraries</a><a class="previous-page" href="/webpack_react/linting_in_webpack">Linting in webpack</a></div><div class="header-extra"><a href="https://www.flickr.com/photos/7870246@N03/481256246">Acid Pix (CC BY)</a></div><script type="text/javascript">var disqus_shortname = 'survivejs';(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script></div><noscript></noscript></main></div></body></html>